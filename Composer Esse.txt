1. Namespaces

Пространства имен призваны добавить стуктурность и устранить проблему дублирования имен сущностей (классов, функций, переменных и т.д.).
При использовании ключевого слова namespace в файлах проекта, при обращении к ним (при использовании require_once) необходимо будет уточнять имя класса добавлением пространства имени перед ним.
Чтобы каждый раз не прибегать к этому, возможно использование ключевого слова use. Это также позволяет при необходимости создавать псевдонимы классов. Это особенно актуально при конфликте имен классов.
Автозагрузка классов позволяет избавиться от require_once. При этом автозагрузчик ищет файл с определением класса, опираясь на полное имя класса, включающее в себя пространство имен и название класса.
Помимо этого (особенно в composer), используются псевдонимы, то есть класс может находиться в месте, напрямую не привязанном к пространству имен.
В Yii2 можно добавить класс в карту классов, которую необходимо сформировать в процессе первоначальной загрузки, так как она должна быть готова до использования классов.

2. Composer

Это пакетный менеджер зависимостей PHP. Различные фреймворки используют Composer. Он актуален в проектах, где используются компоненты со своими зависимостями.
Для его использования достаточно наличия самого менеджера, а также, либо файла composer.json в директории проекта или компонента, либо выполнения команды composer require, которая создаст или обновит composer.json.
Все скачанные пакеты хранятся в папке vendor.
В файле composer.json находится описание проекта или компонента, зависимости от других компонентов, и другая полезная информация.
Добавить компонент можно путем использования команды composer require, или путем ручного редактирования файла composer.json, и последующей командой composer install или composer update.
Также для менеджера есть команды инициализации и самообновления.
Для этого менеджера должны существовать репозитории, где хранятся используемые им пакеты. По умолчанию - это репозиторий packagist.org.

3. Git tags 

Версии проекта соответствуют важным логически завершенным коммитам.
Каждой версии соответствует описание (Change log), которое доступно всем членам команды, как программистам, так и менеджерам, и т.д.

Некоторые команды для работы с версиями:
git tag -a v1.4 -m 'my version 1.4' //Создание метки
git tag //Просмотр имеющихся меток
git show-ref --tags //Просмотреть тэги с коммитами, на которые теги ссылаются

Семантическое версионирование:
Например, 3.2.11
3 - мажорная версия (обратно не совместимая с предыдущей версией)
2 - минорная совместимость (обратная совместимость присутствует) Возможно обновление в пределах минорной версии.
11 - патч-версия (Исправление)

4. Собственные composer пакеты

Для создания своего пакета создаем отдельный проект-пакет.
При тестировании пакета из другого приложения-хоста на данном этапе необходимые неймспейсы не будут работать. Можно временно воспользоваться aliases в настройках приложения-хоста.
В нем же возможно придется подключить и другие зависимые пакеты.
После создания пакета в корне нашего пакета редактируем файл composer.json.
Для этого можно воспользоваться командой "composer init". Указываем там наименование (разработчик/название пакета), описание, тип лицензии и др.
Обращаем внимание на зависимости и блок автозагрузки, влияющий на неймспейсы.
Импортируем необходимые файлы в систему контроля версий (git), включая composer.json. Создаем репозиторий в github. Делаем push. Указываем версию с помощью git tag (1.0.0).
Также, у нас должен быть аккаунт в packagist.org. Импортируем туда наш проект с github. Автообновление там автоматически подключается.
В приложении-хосте убираем зависимые пакеты, используемые при создании нашего пакета, убираем aliases.
После всего этого проверяем работоспособность нашего пакета командой composer require, и тестируем его.